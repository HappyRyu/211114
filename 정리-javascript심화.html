Java Script  상위버전? Type Script
             백엔드 호환? Node JS

source창에서 브레이크를 걸 수 있음
상위프로그램 React

ecma->자바 공식 사이트
Mozilla.org=>개발자가 많이 모이는 사이트

var호이스팅=블럭무시
let ->엄격한 var (현업에서는 var를 거의 사용하지 않음)
const->변경불가(Constant)
숫자+N= 빅인트로 53자리?초과시에 사용(쓸일은 거의 없음)

Immutable Data Types : Premitive type,  frozen objects
Mutable Date Types : All objects in JS (특정 설정 제외)
'my'+' cat'= my cat   글자+글자=글자합
'1'+2 = 12            글자+숫자=글자합
`string literals: 1 + 2 = ${1+2}`  string literals: 1 + 2 = 3

1+1=2 덧셈
1-1=0 뺄셈
1/1=1 나눗셈
1*1=1 곱셈
5%2=1 나머지
2**3=8 거듭제곱

++counter counter에 1을 더한 후 처리
counter++ counter를 처리한 후 1을 더함
--counter counter에 1을 뺀 후 처리
counter-- counter를 처리한 후 1을 뺌
++, --의 순서에 따라 반복 조건문 시작순서 처리하기가 용이하다

and, or 연산자에 check를 넣을 경우 맨 뒤에 넣어 원하는 상황에서만 작동할 수 있게 한다.

! = not연산자로 true는 false로 false는 true로 바꿔준다.

== 같다 (같으면 true) != 같지 않다 (같으면 false)
=== 타입까지 같다 (같으면 true) !== 타입까지 같은 상태가 아니다 (같으면 false)
(strict equality인 === !==를 사용하는 버릇을 가지는 것이 좋다.)

console.log(0 == false);          True
console.log(0 === false);         False
console.log('' == false);         True
console.log('' === false);        False
console.log(null == undefined);   True
console.log(null === undefined);  False
0,공백, null, undefined는 모두 false값으로 동잏하지만 같은 타입이 아니므로
== 비교시에는 True가 나오지만 ===비교시에는 False가 나온다.

const name = '내용';
If (name = '내용') {
  console.log('Welcome, 내용!')
} else if (name === '변수') {
  console.log('Hi 변수');
} else {
  console.log('unknown')
}
A 일치시 A`출력, 아니고 B라면 B`출력 그것도 아니면 C`출력

console.log(name === 'A' ? 'a' : 'b')
A이면 a 출력 아니면 b 출력 (간단할 때문 사용)


const Browser = 'IE';
swich (Browser) {
  case 'IE':
    console.log('go away!');
    break;
  case 'Chrome':
    console.log('Welcome!');
    break;
  case 'Firefox':
    console.log('Welcome!');
    break;
  default:
    console.log('same all??');
    break;

  case 'Chrome':
  case 'Firefox':
    console.log('Welcome!');
    break;

}
스위치는 해당하는 경우 원하는 동작 후 break로 빠져나온다.
중복되는 경우에는 통합도 가능하다.

while= 조건문
do{} while= 실행 후 조건문


for (i=3; i>0; i--) {
  console.log(`for: ${1}`);
}

for (let i = 3; i>0; i=i - 1) {
  console.log(`inline variable for : ${i}`);
}
For문을 통해 i 선언(let을 이용해 지역변수 선언하는 것도 좋음)후
조건(i>0) true값일 경우 작동, 후 반복문(i-1, i--)


for (let i =0; i<10; i++) {
  for (let j = 0; j<10; j++) {
    console.log(`i:${i}, j:${j}`)
  }
}
조건 내 조건문으로 변수의 제곱만큼 커지기 때문에 되도록 쓰지 않는 편이 좋다.


break는 즉시 종료하고 탈출, continue는 해당하는 것만 통과하고 반복문 그대로 진행






Funcrion은 계산, 또는 작업을 처리하는 단위로 subprogram이라고도 불린다.
function name(a1,a2,a3) {body... return;}
function은 작업,계산등을 처리하기 때문에 이름은 직관적인 동사형태가 좋다.


function showMessage(message, from = 'unknown'){
  console.log(`${message} by ${from}`)
}
from = 'unknown'을 적지 않을 경우 from 값이 없기 때문에
a , b 입력을 하지 않고 하나의 변수인 a만 입력시
a by undefined로 출력이 되지만 위와 같이 from = 'unknown'을 from값에 지정시
from값을 넣어주지 않을 경우 자동으로 unknown이 출력된다.

function printAll(...args) {
  for (let i=0; i< args.length; i++){
    console.log(arg[i]);
  }

  for (const arg of args) {
    console.log(arg);
  }

  args.forEach((arg) => console.log(arg));
}
뤼의 for문, for문, =>?  3가지는 모두 동일한 결과(args의 내용 모두 출력)를 가진다.

JavaScript에서는 scope라는 말이 있는데
하위차원(실내)에서는 상위차원(실외)를 볼 수 있지만 상위차원에서는 하위차원을 볼 수
없다는 의미인데 선팅을 했다고 생각하면 이해하기 쉽다.
지역변수(하위차원에 선언된 변수가 상위차원에서는 작동하지 않는 것)도 scope와 관련있다.
- var는 scope를 무시하기 때문에 소규모가 아닌 프로젝트에서는 충돌이 나올 가능성이 크다.
- Function도 호이스팅이 되기 때문에? (선언을 최 상단으로 올려줌) 선언 전 작성한 문장도
정상 작동한다.

function sum(a,b) {
  return a+b;
}
const result = sum(1,2);
console.log(`sum:${sum(1,2)}`);
 sum(a+b)에 대해서 정의한 후 return으로 결과를 받고
 그 받은 값을 sum: 뒤에 출력(console.log)해야만 값을 눈으로 볼 수 있다.
정의(return으로 결과받기), 변수입력, 출력 중 하나라도 부족하면 제대로 작동하지 않는다.

early return이란 조건확인과 작동을 함께 두면 가독성이 떨어지기 때문에
return으로 조건에 맞지 않는 변수일 경우 return으로 넘기고 조건에 맞는 경우에만
따로 떨어져 있는 작업을 시행하는 것이다.
아래에서 WORK SOMETHING WITH LONG LINE이란 엄청 길고 식별하기 곤란한 작업이라고 가정했다.
Function something(a) {
  if (a.point >10) {
    WORK SOMETHING WITH LONG LINE
  }
}
Function something(a) {
  if (a.point <=10) {
    return;
  }
  WORK SOMETHING WITH LONG LINE
}

const print = function() {
  console.log ('print');
} ;
print();
function에서 바로 print 출력을 print();에 보내 print출력

???의 이름을 print로 추가지정하는 경우에도 ???();는 print();와 동일 작동한다

function quiz(answer, printYes, printNo){
  if (answer === '정답'){
    printYes();
  } else {
    printNo();
  }
}
const printYes = function() {
  console.log('Yes!');
};
const printNo = function() {
  console.log('No!')''
}
quiz('정답','printYes','PrintNo');
위의 경우 정답을 입력하면 yes가 출력, 틀리면 no가 출력되지만
왜 저렇게 만드는 법을 가르치는지는 이해할 수 없다..
yes!와 No!를 출력할 경우 함수값만 넣으려는 걸까?
그렇다고 해도 변수를 3개나 넣을 필요 없이 정답입력만 넣고
if와 else뒤에 펑션두개를 유지해도 작동은 그대로 할 것 같다.

@ arrow function는 function을 간략화해주는 착한 도구
const simplePrint = () => console.log('simplePrint!')
const add = (a,b) => a+b;

(function hello() {
  console.log('IIFE');
})();  함수를 ()로 묶은 후 바로 뒤에 ();를 추가할 경우 선언과 동시에 호출이 된다.(IIFE)
